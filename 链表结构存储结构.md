# 代码
```c++
typedef struct Node
{
    ElemType data;
    struct Node *next;
}Node,*Linklist;
```
# 拆分
这一整个代码可以看成是三个内容的组合
##### 结构体类型（struct）
这个部分其实就是
```c++
struct Node //结构体类型名
{
    ElemType data;  //数据域
    struct Node *next;     //指针域
}
```
表示定义了一个叫Node的结构体类型

##### 用户自定义类型（typedef ）

其中一部分是用户自定义类型的
```c++
typedef struct Node //结构体类型名
{

}Node,*Linklist;    //新结构体名1,*新结构体名2;
```
表示现在通过typedef
将叫Node的结构体类型重命名为Node
并且还有一个指向Node结构体类型的指针叫做Linkist

也就是相当于  Node *p==Linklist p
因此，在具体使用指针中两个变量有不同的使用方法：

 - Node p
  p不是指针，引用要用‘.’
    p.data;
  p.next;
 - Linklist l;
    l是指针，引用要用‘->’   
    l->data;
  l->next;

# 要点
##### 对struct Node *next的理解
1.struct Node在在结构体定义中能使用
是因为第一行的定义就已经表示有这个结构体类型名了
所以在即使在里面也可以重复使用

2.表示有个指向Node类型的指针叫next，因为next要表示下一个结点（Node）的地址，类型一定要一致
同时它也是结构体变量所占内存单元的起始地址

##### next怎么指向下一结点
因为next作为指针
它的根本意义是地址
并且是所在的结构体变量的新的随机的地址

但是next不仅作为指针，它还具有结构体类型
在next中还有新的data、next
通过next的地址指引到新的结构体（结点Node）
就完成了指向下一结点的动作